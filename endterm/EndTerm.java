package endterm;

public class EndTerm {

	/* DECEMBER 14th 2018
	 * 
	 * Recursion
	 * Binary Trees (tree expressions)
	 * 	BST
	 * 	Heaps
	 * Sorting
	 * 	O(n^2)
	 *	  selection
	 * 	  insertion
	 * 	O(nlogn)
	 * 	  heap
	 * 	  merge
	 * 	O(n^2) - better in practice
	 * 	  quick sort
	 * Hashing
	 * Self-balancing Trees
	 * 	AVL trees
	 */
	
	/*
	 * 1. 1 of these (maybe or tracing): Build / Destroy a Heap
	 * 2. 1 of these: Trace through a sorting algorithm (quiz w/ bubble sort, insertion, etc. - probably not one of those,
	 * probably not heap sort. so merge sort or quick sort. merge sort is easy to trace through. more difficult
	 * is quick sort. trace is through quick sort, not partitioning. so you just show the output of each iteration.
	 * don't need to do partitioning stuff. just add to cheat sheet the partition algorithm and add the result.
	 * median of 3 - ensures quicksort isn't so much n^2, but more like nlogn. partitioning is linear (n)
	 * 3. 2 of these: programming question with trees - binary trees (possibly BST). likely not implementing binary tree
	 * given binary tree implementation / BST, do this algorithm (based on exercise booklet)
	 * 4. 1 of these: Hashing - programming involved w/ hashing (how to implement insertion to hash table, lookup in hash table
	 * insertion or lookup, not necessarily (probably not) deletion - linear probing. use .hashCode() to get the code
	 * 5. 1 AVL tree question - for insertion, deletion, build a tree
	 * know time complexities above. hashing is always O(1). rehashing is a price to pay
	 * how does median of 3 affect time complexity?
	 */
}
